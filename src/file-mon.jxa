
(ns file-mon
    (require file timer io os lists string (erlang :as erl))
    (use (joxa-core :only (and/1 let/2 if/3))
	 (io_lib :only (format/2))
	 (flow-utils :only (wait-for-file/3 multicast/2))))


;; monitors the open device for new lines, which are sent to a list of processes
(defn monitor-device (file-name dev timeout-ms retries-past-close done-func targets)
  (case (file/read_line dev)
	({:ok line} (multicast {:line line} targets)
	            (monitor-device file-name dev timeout-ms
				    retries-past-close done-func targets))
	;; eof is returned when there is no more data to be read in right now
	(:eof (if (done-func)
		  ;; if we are done and past all retry attempts, transmit :eof and exit
		  (if (erl/== retries-past-close 0)
		      ; no success/failure code is returned
		      (multicast :eof targets)
		      (do (timer/sleep timeout-ms)
			  (monitor-device file-name dev timeout-ms
					  (erl/- retries-past-close 1) (fn () :true) targets)))
;		  ;; not done yet, sleep for the given timeout time
		  (do (timer/sleep timeout-ms)
		      (monitor-device file-name dev timeout-ms
				      retries-past-close done-func targets))))
	;; there has been an error
	({:error reason} 
	 (multicast  {:failure (format "failed to watch file ~s with reason ~p" [file-name reason])}
		     targets))))


;; monitor the file file-name while checking whether writing to the file is considered done
;; using done-func and transmitting lines/eof messages to all targets
;; when the file is closed, the monitor exits by itself
(defn+ monitor-file (file-name done-func targets)
  ;; wait max 4 seconds for the file to appear in case it's visible immediately
  (case (wait-for-file file-name 4000 200)
	({:success _f} 
	 {:pid (erl/spawn (fn () (let ({:ok dev} (file/open file-name [:read]))
					   (monitor-device file-name dev 500 2 done-func targets)
					   (file/close dev))))})
	(failure failure)))
